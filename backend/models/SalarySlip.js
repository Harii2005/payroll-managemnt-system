const mongoose = require('mongoose');

const salarySlipSchema = new mongoose.Schema({
  employeeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Employee ID is required']
  },
  month: {
    type: Number,
    required: [true, 'Month is required'],
    min: [1, 'Month must be between 1 and 12'],
    max: [12, 'Month must be between 1 and 12']
  },
  year: {
    type: Number,
    required: [true, 'Year is required'],
    min: [2020, 'Year must be 2020 or later'],
    max: [new Date().getFullYear() + 1, 'Year cannot be more than next year']
  },
  basicSalary: {
    type: Number,
    required: [true, 'Basic salary is required'],
    min: [0, 'Basic salary cannot be negative']
  },
  allowances: {
    hra: {
      type: Number,
      default: 0,
      min: [0, 'HRA cannot be negative']
    },
    transport: {
      type: Number,
      default: 0,
      min: [0, 'Transport allowance cannot be negative']
    },
    medical: {
      type: Number,
      default: 0,
      min: [0, 'Medical allowance cannot be negative']
    },
    special: {
      type: Number,
      default: 0,
      min: [0, 'Special allowance cannot be negative']
    },
    overtime: {
      type: Number,
      default: 0,
      min: [0, 'Overtime cannot be negative']
    },
    bonus: {
      type: Number,
      default: 0,
      min: [0, 'Bonus cannot be negative']
    }
  },
  deductions: {
    tax: {
      type: Number,
      default: 0,
      min: [0, 'Tax cannot be negative']
    },
    pf: {
      type: Number,
      default: 0,
      min: [0, 'PF cannot be negative']
    },
    insurance: {
      type: Number,
      default: 0,
      min: [0, 'Insurance cannot be negative']
    },
    loan: {
      type: Number,
      default: 0,
      min: [0, 'Loan deduction cannot be negative']
    },
    other: {
      type: Number,
      default: 0,
      min: [0, 'Other deductions cannot be negative']
    }
  },
  workingDays: {
    total: {
      type: Number,
      required: [true, 'Total working days is required'],
      min: [1, 'Total working days must be at least 1'],
      max: [31, 'Total working days cannot exceed 31']
    },
    worked: {
      type: Number,
      required: [true, 'Worked days is required'],
      min: [0, 'Worked days cannot be negative']
    }
  },
  netSalary: {
    type: Number,
    default: 0
  },
  pdfUrl: {
    type: String,
    trim: true
  },
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Generated by is required']
  },
  status: {
    type: String,
    enum: ['draft', 'finalized', 'sent'],
    default: 'draft'
  },
  emailSent: {
    type: Boolean,
    default: false
  },
  emailSentAt: {
    type: Date
  },
  notes: {
    type: String,
    trim: true,
    maxlength: [500, 'Notes cannot exceed 500 characters']
  }
}, {
  timestamps: true
});

// Compound index to ensure one salary slip per employee per month/year
salarySlipSchema.index({ employeeId: 1, month: 1, year: 1 }, { unique: true });
salarySlipSchema.index({ status: 1, createdAt: -1 });
salarySlipSchema.index({ year: -1, month: -1 });

// Calculate net salary before saving
salarySlipSchema.pre('save', function(next) {
  // Calculate total allowances
  const totalAllowances = Object.values(this.allowances).reduce((sum, value) => sum + (value || 0), 0);
  
  // Calculate total deductions
  const totalDeductions = Object.values(this.deductions).reduce((sum, value) => sum + (value || 0), 0);
  
  // Calculate pro-rated salary based on working days
  const proRatedSalary = (this.basicSalary / this.workingDays.total) * this.workingDays.worked;
  
  // Calculate net salary
  this.netSalary = proRatedSalary + totalAllowances - totalDeductions;
  
  next();
});

// Validation to ensure worked days don't exceed total days
salarySlipSchema.pre('save', function(next) {
  if (this.workingDays.worked > this.workingDays.total) {
    next(new Error('Worked days cannot exceed total working days'));
  } else {
    next();
  }
});

// Virtual for month name
salarySlipSchema.virtual('monthName').get(function() {
  const months = [
    'January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'
  ];
  return months[this.month - 1];
});

// Virtual for formatted net salary
salarySlipSchema.virtual('formattedNetSalary').get(function() {
  return new Intl.NumberFormat('en-IN', {
    style: 'currency',
    currency: 'INR'
  }).format(this.netSalary);
});

// Instance method to get total allowances
salarySlipSchema.methods.getTotalAllowances = function() {
  return Object.values(this.allowances).reduce((sum, value) => sum + (value || 0), 0);
};

// Instance method to get total deductions
salarySlipSchema.methods.getTotalDeductions = function() {
  return Object.values(this.deductions).reduce((sum, value) => sum + (value || 0), 0);
};

// Instance method to finalize salary slip
salarySlipSchema.methods.finalize = function() {
  this.status = 'finalized';
  return this.save();
};

// Instance method to mark as sent
salarySlipSchema.methods.markAsSent = function() {
  this.status = 'sent';
  this.emailSent = true;
  this.emailSentAt = new Date();
  return this.save();
};

// Static method to get salary slips by employee
salarySlipSchema.statics.getEmployeeSalarySlips = function(employeeId, year = null) {
  const query = { employeeId };
  if (year) query.year = year;
  
  return this.find(query)
    .populate('employeeId', 'name email employeeId department')
    .populate('generatedBy', 'name email')
    .sort({ year: -1, month: -1 });
};

// Static method to get salary slips by period
salarySlipSchema.statics.getByPeriod = function(month, year) {
  return this.find({ month, year })
    .populate('employeeId', 'name email employeeId department')
    .populate('generatedBy', 'name email')
    .sort({ 'employeeId.name': 1 });
};

// Transform JSON output
salarySlipSchema.methods.toJSON = function() {
  const salarySlip = this.toObject({ virtuals: true });
  return salarySlip;
};

module.exports = mongoose.model('SalarySlip', salarySlipSchema);
